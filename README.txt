Χρίστος Ιωάννου
Α.Μ: 1115201900222

------------------------------------------------------------------------------------------------------------------------

Execution instructions:

$ make ALL
$ ./dataServer -p <port> -s <thread_pool_size> -q <queue_size> -b <block_size>
$ ./remoteClient -i <server_ip> -p <server_port> -d <directory>

------------------------------------------------------------------------------------------------------------------------

-----------------------------
|    Γενικές Σημειώσεις:    |
-----------------------------
1) Υπάρχουν κομμάτια κώδικα τα οποία έχω πάρει από τις διαφάνειες (συνάρτηση "perror_exit", κώδικας για δημιουργία των 
   sockets, συμπεριλαμβανομένων των structs, αρχικοποίηση των πεδίων τους, bind, listen, accept κλπ).
2) Όταν δίνετε όρισμα <directory> για το ./remoteClient να μην υπάρχει '/' στο τέλος του ορίσματος καθώς σε κάποια
   σημεία (όταν π.χ υπάρχουν υποφακέλοι) το προσθέτω εγώ οπότε αν υπάρχει το '/' μπορεί να διαβαστεί κάποιο path ως
   εξής "Server//test/file1" το οποίο θα προκαλέσει πρόβλημα.
3) Η δημιουργία του καταλόγου προς αντιγραφή <directory> γίνεται μέσα σε έναν άλλο φάκελο "output" τον οποίο κάνω define
   στο 'remoteClient.cpp'.

-----------------------------
|      dataServer.cpp       |
-----------------------------
Αν και δεν είναι απαραίτητο έχω φτιάξει ένα sigaction που ανιχνεύει το σήμα SIGINT για να γίνεται ένα μερικό cleanup.

Αρχικά, γίνεται έλεγχος για το εάν εκτελέστηκε σωστά το πρόγραμμα και έπειτα αρχικοποιούνται τα ορίσματα που δόθηκαν,
όπως και τα conditional variables & mutex που θα χρειαστούν για την πρόσβαση στην ουρά εκτέλεσης (work_queue).

Έπειτα, φτιάχνετε το thread pool (tids) το οποίο δημιουργεί <thread_pool_size> worker threads. Μέσα σε ένα infinite
while loop "while(1)", ο dataServer κάνει συνεχώς accept κάποιο connection και δημιουργεί ένα νέο communication thread,
δίνοντας ως όρισμα το socket που πήρε από την accept.

Στο communication thread (comm_thread) αρχικοποιείται ένα mutex το οποίο θα χρησιμοποιηθεί ώστε να κάνει lock κάθε
worker thread και να εμποδιστεί η πρόσβαση για διάβασμα/γράψιμο στο ίδιο socket από κάποιο άλλο worker thread ("ο server
θα πρέπει να εξασφαλίζει κατά τη διάρκεια εκτέλεσης του, ότι στο socket κάθε πελάτη γράφει δεδομένα μόνο ένα worker
thread τη φορά"). Αυτό το mutex είναι "static" έτσι ώστε να μη "πεθαίνει" όταν τελειώσει το communication thread (θα
γίνεται destroy από worker thread - θα γίνει αναφορά στη συνέχεια) και "thread_local" ώστε κάθε διαφορετικό
communication thread να δημιουργεί δικό του (δηλαδή διαφορετικό κάθε φορά).

Σε αυτό το σημείο να αναφέρω ότι η ουρά εκτέλεσης περιέχει map με κλειδί κάποιο όνομα αρχείου και value το socket που
του αναλογεί. Έχω επίσης υλοποιήσει 2 άλλα βοηθητικά maps για να παίρνω κάποιες απαραίτητες πληροφορίες που χρειάζονται
στα worker threads, το "files_per_socket" με κλειδί ένα socket και value τον αριθμό των αρχείων που έχει και "sock_mtx"
με κλειδί ένα socket και value δείκτη σε κάποιο mutex.

Στο communication thread λοιπόν διαβάζεται από το socket το όνομα του καταλόγου προς αντιγραφή και γίνεται αρχικοποίηση
της τιμής του socket στο map "files_per_socket" με 0 και του map "sock_mtx" με το mutex που φτιάχτηκε προηγουμένως.
Ακολούθως, καλείται 2 φορές η αναδρομική συνάρτηση "find_files" τη μια φορά με flag 0 (τελευταίο όρισμα - που υποδηλώνει
ότι θέλουμε να μετρήσουμε τον αριθμό των αρχείων) και την άλλη φορά με flag 1 (που υποδηλώνει ότι θέλουμε να βάλουμε τα
αρχεία στην ουρά εκτέλεσης).

Στη συνάρτηση "find_files" γίνεται έλεγχος αν ο τύπος είναι κατάλογος, τότε ξανακαλείται η συνάρτηση "find_files" με το
ανανεωμένο path και dir_entry, διαφορετικά αν είναι regular file πρέπει να προστεθεί στην ουρά εκτέλεσης. Αυτό
επιτυγχάνεται κάνοντας lock το global mutex, γίνεται η δουλειά που είναι να γίνει και unlock το mutex. Μετά το lock,
πρέπει να γίνει έλεγχος αν η ουρά εκτέλεσης είναι γεμάτη, τότε το 1o condition variable πρέπει να περιμένει μέχρι να
γίνει signal ("Στην περίπτωση που η ουρά εκτέλεσης είναι γεμάτη, το communication thread που εξυπηρετεί τον πελάτη θα
πρέπει να περιμένει μέχρι να δημιουργηθεί ελεύθερος χώρος"). Αν είναι εντάξει, εκτυπώνεται το ανάλογο μήνυμα και
προστίθεται το αρχείο (με το socket) στην ουρά. Αν μετά από αυτό το βήμα το queue δεν είναι άδειο, γίνεται signal το 2ο
conditional variable (αυτό του worker thread).

Με αντίστοιχο τρόπο, σε ένα infinite while loop "while(1)" κάνει lock το mutex, αν η ουρά είναι άδεια, block-άρει το 2ο
conditional variable και περιμένει μέχρι να γίνει signal από το communication thread - αναδρομική συνάρτηση "find_files"
("Σε περίπτωση που η ουρά εκτέλεσης είναι κενή, τα worker threads θα πρέπει να περιμένουν μέχρι να υπάρξει κάποια
εγγραφή στην ουρά"). Αν είναι εντάξει, παίρνουμε το πρώτο αρχείο (με το socket) από την ουρά αλλά και το mutex μέσω του
map "sock_mtx". Εκτυπώνεται το ανάλογο μήνυμα, γίνεται έλεγχος αν το work_queue δεν είναι πλέον γεμάτο ώστε να γίνει
signal το 1ο conditional variable (και να μπορεί κάποιο communication thread να γράψει) και unlock to global mutex.
Στη συνέχεια, ανοίγουμε το αρχείο που πήραμε και με τη χρήση της fseek με κατάλληλα ορίσματα, παίρνουμε πόσα bytes
υπάρχουν μέσα στο αρχείο. Αυτή την πληροφορία θα τη στείλουμε ως metadata έτσι ώστε να ξέρει ο remoteClient πότε
τελείωσε με το διάβασμα κάποιου αρχείου. Μετά, γίνεται lock το mutex που πήραμε προηγουμένως για να απαγορευτεί η
πρόσβαση από άλλο worker_thread να γράψει στο ίδιο socket, μειώνεται ο μετρητής αρχείων στο map "files_per_socket" και
αποθηκεύουμε την ανανεωμένη τιμή σε μια μεταβλητή "file_count". Πρώτα, γράφεται μέσω του socket το όνομα του αρχείου
(ουσιαστικά περιέχεται και το path το οποίο "σπάω" σε κομμάτια στο remoteClient). Μετά, γράφονται τα metadata, το
filesize και το file_count. Το file_count χρειάζεται ώστε να ξέρει ο remoteClient πότε να τερματίσει, ότι παρέλαβε όλα
τα files τα οποία ζήτησε. Σε ένα while loop διαβάζονται τα περιεχόμενα του αρχείου και γράφονται μέσω socket ανά block
(το πολύ <block_size> bytes θα διαβάζονται και θα αποστέλλονται). Ενδιάμεσα υπάρχουν κάποια reads - αποστολή μηνυμάτων
μεταξύ worker thread και remoteClient ώστε να επιτευχθεί σωστή επικοινωνία.
Τέλος, γίνεται unlock το mutex και γίνεται έλεγχος αν το "file_count" είναι 0, τότε πρέπει να σβηστούν τα δεδομένα του
socket από τα δύο maps, να κλείσει το (ένα άκρο του) socket και να γίνει destroy το mutex. 

-----------------------------
|     remoteClient.cpp      |
-----------------------------
Έλεγχος αν εκτελέστηκε σωστά το πρόγραμμα και αρχικοποίηση των ορισμάτων. Δημιουργία του socket, σύνδεση με το
dataServer και γράψιμο του καταλόγου προς αντιγραφή. Σε ένα infinite while loop while(1) διαβάζεται πρώτα το όνομα του
αρχείου (περιέχεται το path), "σπάει" το path σε κομμάτια δημιουργώντας όλους τους υποκαταλόγους που χρειάζονται.
Ακολούθως, δημιουργείται το αρχείο (διαγράφεται σε περίπτωση που υπάρχει ήδη), διαβάζονται τα metadata (στέλνοντας
μηνύματα "OK" αφότου τα παραλάβει) και έπειτα τα περιεχόμενα του αρχείου μέχρι το filesize να γίνει ίσο με 0. Για το
διάβασμα των περιεχομένων του αρχείου από το socket δεν αναφέρεται στην εκφώνηση αν πρέπει να γίνει και αυτό ανά block
οπότε όρισα εγώ ένα buffer έστω μεγέθους 512. Αν έπρεπε να διαβάζεται και από το socket ανά block, μια λύση θα ήταν να
γράφεται και το block_size ως metadata και να ορίζεται τότε το μέγεθος του buffer (αφότου πάρει αυτό το metadata ο
remoteClient). Τέλος, αν δοθεί "file_count" ίσο με 0 τότε τερματίζει ο remoteClient.